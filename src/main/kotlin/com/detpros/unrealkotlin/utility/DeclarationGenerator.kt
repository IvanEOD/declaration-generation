package com.detpros.unrealkotlin.utility


/**
 *  Declarations Generator
 *
 * @author IvanEOD ( 5/23/2023 at 2:39 PM EST )
 */


fun kotlinUE5Text() = """// Generated by Detonate Productions Declaration Generation, do not edit manually!
@file:Suppress(
    "INTERFACE_WITH_SUPERCLASS",
    "OVERRIDING_FINAL_MEMBER",
    "RETURN_TYPE_MISMATCH_ON_OVERRIDE",
    "CONFLICTING_OVERLOADS",
)

package ue

public external class UClass

public external interface KotlinUnrealObject {
    @JsName("Tick")
    public fun tick(deltaTime: Float)
    @JsName("BeginOverlap")
    public fun beginOverlap(other: Actor): String
    @JsName("EndOverlap")
    public fun endOverlap(other: Actor)
    @JsName("OnDestroyed")
    public fun onDestroyed()
}

public external class KotlinActorComponent : ActorComponent {
    @JsName("Spawn")
    public fun <T : Actor> spawn(actorClass: UClass, position: Vector, rotation: Rotator): T
}

public open external class KotlinObject : KotlinUnrealObject {
    public val root: KotlinActorComponent
    override fun tick(deltaTime: Float)
    override fun beginOverlap(other: Actor): String = definedExternally
    override fun endOverlap(other: Actor)
    override fun onDestroyed()
}

public fun <T : Actor> KotlinObject.getOwner(): T = root.getOwner().asDynamic() as T

public external var global: dynamic
public external var ComponentRoot: dynamic

private object KotlinUnrealClassCache {
    val cache = mutableMapOf<String, dynamic>()
}

@JsName("unrealProxyClass")
public fun unrealProxyClass(global: dynamic, klass: dynamic, className: String) {
    val GeneratedClassDefinition = if (KotlinUnrealClassCache.cache.containsKey(className))
        KotlinUnrealClassCache.cache[className]
    else {
        val value = js("require('uklass')()(global, klass)")
        KotlinUnrealClassCache.cache[className] = value
        value
    }
    val instance = js("new GeneratedClassDefinition()")
    instance.Root = ComponentRoot
    instance.Root.SetKotlinObject(instance)
    instance.konstructor()
    if (!global.precious) global.precious = js("[]"); global.precious.push(instance)
}

public fun Vector(
    x: Number = 0,
    y: Number = 0,
    z: Number = 0,
): Vector = Vector().apply {
    this.x = x.toDouble()
    this.y = y.toDouble()
    this.z = z.toDouble()
}

public fun Rotator(
    roll: Number = 0,
    pitch: Number = 0,
    yaw: Number = 0,
): Rotator = Rotator().apply {
    this.roll = roll.toDouble()
    this.pitch = pitch.toDouble()
    this.yaw = yaw.toDouble()
}

public fun LinearColor(r: Number = 0, g: Number = 0, b: Number = 0, a: Number = 1): LinearColor = ue.LinearColor().apply {
    this.r = r.toDouble()
    this.g = g.toDouble()
    this.b = b.toDouble()
    this.a = a.toDouble()
}

public inline fun Vector.withX(x: Number): Vector = this.apply { this.x = x.toDouble() }
public inline fun Vector.withY(y: Number): Vector = this.apply { this.y = y.toDouble() }
public inline fun Vector.withZ(z: Number): Vector = this.apply { this.z = z.toDouble() }

public inline fun Rotator.withRoll(roll: Number): Rotator = this.apply { this.roll = roll.toDouble() }
public inline fun Rotator.withPitch(pitch: Number): Rotator = this.apply { this.pitch = pitch.toDouble() }
public inline fun Rotator.withYaw(yaw: Number): Rotator = this.apply { this.yaw = yaw.toDouble() }

public fun <T> Blueprint.generateClass(world: World, position: Vector, rotation: Rotator): T {
    val receiver = this
    return js("new receiver.generatedClass(world, position, rotation)").unsafeCast<T>()
}

public fun <T> MovieSceneSpawnable.generateClass(world: World, position: Vector, rotation: Rotator): T {
    val receiver = this
    return js("new receiver.generatedClass(world, position, rotation)").unsafeCast<T>()
}

public fun <T> Actor.getComponentByName(componentClass: Any, name: String): T {
    val nameToCheck = name.lowercase()
    val components = getComponentsByClass(componentClass).filter { it.getName().lowercase() == nameToCheck }
    if (components.isEmpty()) return null as T
    return components.first().asDynamic().unsafeCast<T>()
}

public fun <T> Actor.getComponentByClass(componentClass: Any): T = getComponentByClass(componentClass).asDynamic().unsafeCast<T>()
public fun <T> Actor.getComponentsByClass(componentClass: Any): Array<T> = getComponentsByClass(componentClass).asDynamic().unsafeCast<Array<T>>()

public fun Key(keyName: String): Key = Key().apply { this.keyName = keyName }

public class KeyListener(keyName: String, private val playerControllerIndex: Int = 0) {
    private val k = Key(keyName)
    public fun down(): Boolean = GWorld.getPlayerController(playerControllerIndex).isInputKeyDown(k)
    public fun pressed(): Boolean = GWorld.getPlayerController(playerControllerIndex).wasInputKeyJustPressed(k)
    public fun released(): Boolean = GWorld.getPlayerController(playerControllerIndex).wasInputKeyJustReleased(k)
}

""".trimIndent()